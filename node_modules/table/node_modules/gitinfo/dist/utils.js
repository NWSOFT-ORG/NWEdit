"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findGitPath = exports.isGitDirectory = exports.parseRemoteOriginUrl = exports.parseIni = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _url = _interopRequireDefault(require("url"));

var _ini = _interopRequireDefault(require("ini"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @flow

/**
 * Converts [INI](https://en.wikipedia.org/wiki/INI_file) string into an object.
 *
 * @access protected
 */
const parseIni = name => {
  let config;
  /* istanbul ignore next */

  if (!_fs.default.existsSync(name)) {
    throw new Error('INI file ("' + name + '") does not exist.');
  }

  config = _fs.default.readFileSync(name, {
    encoding: 'utf8'
  });
  config = _ini.default.parse(config);
  return config;
};
/**
 * Extracts information about the the repository from the
 * supplied URL (presumably, the remote origin URL).
 *
 * @access protected
 * @param input Supported Git remote origin URL (https, git or SVN).
 */


exports.parseIni = parseIni;

const parseRemoteOriginUrl = input => {
  let url; // git@github.com:gajus/gitdown.git
  // https://github.com/gajus/gitdown.git
  // https://github.com/gajus/gitdown

  if (input.includes('com:')) {
    url = input.split('com:')[1];
  } else {
    const parsedUrl = _url.default.parse(input);

    if (parsedUrl && parsedUrl.path) {
      url = parsedUrl.path.slice(1);
    } else {
      /* istanbul ignore next */
      throw new Error('Cannot parse origin URL.');
    }
  }

  if (/\.git$/.test(url)) {
    url = url.slice(0, -4);
  }

  url = url.split('/');
  /* istanbul ignore next */

  if (url.length !== 2) {
    throw new Error('Invalid remote origin URL ("' + input + '").');
  }

  return {
    name: url[1],
    username: url[0]
  };
};
/**
 * Tells whether a supplied path is a .git directory.
 *
 * @access protected
 */


exports.parseRemoteOriginUrl = parseRemoteOriginUrl;

const isGitDirectory = path => {
  try {
    _fs.default.statSync(path + '/HEAD');

    _fs.default.statSync(path + '/objects');

    _fs.default.statSync(path + '/refs');

    _fs.default.statSync(path + '/config');

    return true;
  } catch (error) {
    return false;
  }
};
/**
 * Finds a .git directory by ascending the directory tree.
 *
 * @access protected
 * @param startPath The path where to start the search.
 */


exports.isGitDirectory = isGitDirectory;

const findGitPath = startPath => {
  let dirname;
  let gitpath;
  dirname = startPath;

  do {
    if (_fs.default.existsSync(dirname + '/.git')) {
      gitpath = dirname + '/.git';
      break;
    }

    dirname = _fs.default.realpathSync(dirname + '/..');
  } while (_fs.default.existsSync(dirname) && dirname !== '/');
  /* istanbul ignore next */


  if (!gitpath) {
    throw new Error('Cannot locate .git directory.');
  }

  return gitpath;
};

exports.findGitPath = findGitPath;